{
  "version": 3,
  "sources": ["../../../.github/pages/game.js"],
  "sourcesContent": ["const K = {\r\n    /// train statuses, probably.\r\n    MOVING: 1,\r\n    STOPPED: 2,\r\n    // touch action statuses\r\n    NOHOLD: 0,\r\n    HOLD: 1,\r\n    HOLD_NEWLINE: 2,\r\n    // passenger status \r\n    WAITING: 0,\r\n    ONTHEWAY: 1,\r\n    // board/deboard time/passenger\r\n    DELAYPERPASSENGER: 400,\r\n    INF: 9e99,\r\n    /// was supposed to be pi and a bit to make arcs completely touching but it didn't seem to work.\r\n    PI: Math.PI,\r\n    // \r\n    // stop over-capacity timeout\r\n    FAILTIME: 30000,\r\n    LINEWIDTH:10, // width of one line in base-size pixels \r\n    LINEACCEPTDIST: 20, // base-size pixels under which line dragging will be accepted\r\n    // actionStatuses: \r\n    NOACTION:0,\r\n    BOARDPENDING:1, // just boarding \r\n    DEBOARDPENDING:2, // just deboarding\r\n    TRANSFERPENDING:3 // deboarding FOR TRANSFER.\r\n  }\r\n  const trainSpeed = 100 / 1000; // pixels/ms\r\n  let holdState = K.NOHOLD;\r\n  let ctx = null;\r\n  let canv = null;\r\n  let totalScaleFac = 1;\r\n  let hovering = null, hoveringConn = null;\r\n  let stops = [];\r\n  let connections = [];\r\n  let lineTypes = [];\r\n  let stopCt = 0;\r\n  let minSclFac = 0.5;\r\n  const maxSclFac = 3;\r\n  let viewportW = 0;\r\n  let viewportH = 0;\r\n  let viewportMax, viewportMin;\r\n  let currPath = [];\r\n  let typesOnLine = [];\r\n  let lines = [];\r\n  let trains = [];\r\n  let ticketCost = 10;\r\n  let passengersServed = 0;\r\n  let cash = 0;\r\n  let maxUnlockedType = 0;\r\n  const acceptRadius = 30;\r\n  const stopSz = 20;\r\n  let adj = [];\r\n  let passengers = [];\r\n  let currPos_canv = null;\r\n  let lineCt = 0;\r\n  // let hoveringConn = null;\r\n  let shiftStatus = false;\r\n  let downPt = null;\r\n  let types = [triangle, square, circ, star];\r\n  let defaultClr = \"#000\";\r\n  const colours = [\"green\", \"yellow\", \"blue\", \"orange\", \"purple\", \"grey\"];\r\n  let DEBUG = true;\r\n  function onLoad() {\r\n    \r\n  }\r\n  \r\n  function bezier(t , p1, p2, p3){\r\n  return (1-t)**2*p1 + 2*(1-t)*t*p2 + t**2*p3;\r\n  }\r\n  \r\n  function parallelStops(cmp) {\r\n    let ct = 0;\r\n    let idx = -1;\r\n    let flipped = 0;\r\n    for (let i=0; i<connections.length; i++) {\r\n      let cnn= connections[i];\r\n      if (samePt(cnn.from, cmp.from) && samePt(cnn.to, cmp.to)\r\n         || samePt(cnn.from, cmp.to) && samePt(cnn.to, cmp.from)) {\r\n        if (cmp == cnn && idx == -1) {  \r\n          idx=ct;\r\n        }\r\n        if (samePt(cnn.from, cmp.to) && flipped == 0) flipped=1; // ONLY SET THIS ONCE\r\n        else if (flipped == 0) flipped = 2;\r\n        ct++;\r\n      }\r\n    }\r\n    return {idx:idx, flipped:flipped==1, ct:ct};\r\n  }\r\n  \r\n  function getNextStop(currTrain, actQ=true) {\r\n   let currToIdx = currTrain.path.indexOf(nearestStop(currTrain.to,1));\r\n    if (currTrain.revDir && currToIdx == 0)\r\n    {\r\n      if (actQ) currTrain.revDir = !currTrain.revDir;\r\n      nextStop = currTrain.from\r\n    }\r\n    else if (!currTrain.revDir && currToIdx == currTrain.path.length-1) {\r\n      nextStop = currTrain.from;\r\n      if (actQ) currTrain.revDir = !currTrain.revDir;\r\n    }\r\n    else if (currTrain.revDir) {\r\n      nextStop = currTrain.path[currToIdx-1];\r\n    }\r\n    else nextStop = currTrain.path[currToIdx+1]; \r\n    return nearestStop(nextStop, 1);\r\n  }\r\n  \r\n  function handlePassenger(pass) {\r\n    if (pass.status != K.WAITING) return;\r\n    let minRouteLength = K.INF;\r\n    // let minRoute = [];\r\n    for (let l=0; l<pass.from.linesServed.size; l++) {\r\n      let lIdx = Array.from(pass.from.linesServed)[l];\r\n      for (let i=0; i<typesOnLine.length; i++) {\r\n        if (!typesOnLine[i].has(pass.to)) continue;\r\n        if (minRouteLength > adj[lIdx][i].val) {\r\n          minRouteLength = adj[lIdx][i].val;\r\n          // pass.route=adj[lIdx][i].route;\r\n          //WARNING! DO A DEEP COPY\r\n          pass.route = [];\r\n          for (let e of adj[lIdx][i].route)\r\n            pass.route.push(e);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function handleOffset(connection) {\r\n    let angBtw = Math.atan2(connection.to.y - connection.from.y,\r\n      connection.to.x - connection.from.x);\r\n    // angBtw += K.PI;\r\n    let info = parallelStops(connection);\r\n    let offsetR = (K.LINEWIDTH/2)*(2*info.idx+1-info.ct) //+ stopSz;\r\n    let newAng = info.flipped?(angBtw+Math.PI):angBtw;\r\n    return {x:offsetR*Math.cos(newAng+Math.PI/2), y: offsetR*Math.sin(newAng+Math.PI/2)}\r\n  }\r\n  \r\n  function getAssociatedConnection(train) {\r\n    for (let cn of connections) {\r\n      if (samePt(cn.to, train.to) && samePt(cn.from, train.from) || \r\n          samePt(cn.from, train.to) && samePt(cn.to, train.from))\r\n        if (cn.lineID == train.lineID) return cn;\r\n    }\r\n    return null;\r\n  }\r\n  function redraw() {\r\n    ctx.lineCap = \"round\";\r\n    // function connect(currPath, clr) {\r\n    function circle(pt) {\r\n      ctx.save();\r\n      clearCircle(pt, acceptRadius);\r\n      ctx.beginPath();\r\n      ctx.arc(pt.x, pt.y, stopSz, 0, K.PI * 2);\r\n      ctx.stroke();\r\n      // ctx.strokeStyle;\r\n      ctx.beginPath();\r\n      ctx.arc(pt.x, pt.y, acceptRadius, 0, K.PI * 2);\r\n      ctx.stroke();\r\n      ctx.restore();\r\n      ctx.beginPath();\r\n    }\r\n    function clearCircle(pt, rad) {\r\n      ctx.beginPath();\r\n      ctx.fillStyle = getCSSProp(\"--system-grey3\");\r\n      ctx.save();\r\n      ctx.arc(pt.x, pt.y, rad + 2, 0, K.PI * 2);\r\n      ctx.clip();\r\n      ctx.save();\r\n      ctx.resetTransform();\r\n      ctx.clearRect(0, 0, canv.width, canv.height);\r\n      ctx.restore();\r\n      ctx.fill();\r\n      ctx.restore();\r\n      ctx.beginPath();\r\n    }\r\n    updateMinScl();\r\n    ctx.beginPath();\r\n    ctx.save();\r\n    ctx.resetTransform();\r\n    ctx.fillStyle = getCSSProp(\"--system-grey3\");\r\n    ctx.clearRect(0, 0, canv.width, canv.height);\r\n    ctx.fillRect(0, 0, canv.width, canv.height);\r\n    ctx.restore();\r\n    if (DEBUG) {\r\n      ctx.beginPath();\r\n      ctx.lineWidth = 3;\r\n      ctx.moveTo(-viewportW / 2, -viewportH/2);\r\n      ctx.lineTo(viewportW / 2, -viewportH/2);\r\n      ctx.lineTo(viewportW / 2, viewportH/2);\r\n      ctx.lineTo(-viewportW/2, viewportH/2);\r\n      ctx.lineTo(-viewportW/2, -viewportH/2);\r\n      ctx.stroke();\r\n    }\r\n    ctx.beginPath();\r\n    if (hovering) {\r\n      ctx.save();\r\n      ctx.fillStyle = getCSSProp(\"--system-green2\");\r\n      // ctx.strokeWidth = acceptRadius - stopSz;\r\n      ctx.beginPath();\r\n      ctx.arc(hovering.x, hovering.y, acceptRadius, 0, K.PI*2);\r\n      ctx.fill();\r\n      clearCircle({x:hovering.x,y:hovering.y},stopSz);\r\n      ctx.restore();\r\n    }\r\n    ////////// little stop circles //////////\r\n    for (let i = 0; i < stops.length; i++) {\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      if (stops[i].failureTimer > 0) {\r\n        ctx.fillStyle = getCSSProp(\"--system-red2\");\r\n        let pctRemaining = (Date.now() - stops[i].failureTimer)/K.FAILTIME;\r\n        let pctOneSec = (Date.now() - stops[i].failureTimer)/300;\r\n        let radScl = 0;\r\n        if (pctOneSec < 1) \r\n          radScl = (-4*(pctOneSec-0.5)**2)+0.5;\r\n        if (pctRemaining > 1 && pctRemaining < 2) {\r\n          radScl = pctRemaining**120;\r\n        }\r\n        let currRad = stopSz+(acceptRadius-stopSz)*2+10*radScl;\r\n        \r\n        // let radiusFcn = \r\n        // cubic-bezier( 0.175, 0.885, 0.32, 1.275 )\r\n        \r\n        ctx.beginPath();\r\n        ctx.moveTo(stops[i].x, stops[i].y);\r\n        // ctx.strokeStyle = getCSSProp(\"--system-transp\");\r\n        ctx.arc(stops[i].x, stops[i].y, currRad, 0, Math.PI*pctRemaining*2);\r\n        // ctx.stroke();\r\n        ctx.fill();\r\n        ctx.fill();\r\n        ctx.lineCap = \"round\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(stops[i].x+currRad, stops[i].y);\r\n        ctx.arc(stops[i].x, stops[i].y, currRad, 0, Math.PI*pctRemaining*2);\r\n        ctx.strokeStyle = getCSSProp(\"--system-red\");\r\n        // ctx.lineTo(stops[i].x, stops[i].y);\r\n        ctx.stroke();\r\n        ctx.beginPath();\r\n      }\r\n      ctx.restore();\r\n      clearCircle(stops[i], stopSz);\r\n      ctx.arc(stops[i].x, stops[i].y, stopSz, 0, K.PI * 2);\r\n      ctx.stroke();\r\n      ctx.beginPath();\r\n      ctx.fillStyle = defaultClr;\r\n      let out = \" \";\r\n      for (let j = 0; j < stops[i].waiting.length; j++) {\r\n        out += stops[i].waiting[j].to.toString();\r\n      }\r\n      ctx.fillText(out, stops[i].x + stopSz, stops[i].y - stopSz / 2);\r\n      ctx.fillText(stops[i].type, stops[i].x, stops[i].y)\r\n      // if ()\r\n    }\r\n    // existing paths///////////\r\n    for (let i = 0; i < connections.length; i++) {\r\n      // if (lines.length > 0) ctx.arc(lines[i][0].x, lines[i][0].y, acceptRadius, 0, K.PI*2);\r\n      // // for (let i=1; i<currPath.length; i++) {\r\n      let offset = handleOffset(connections[i]);\r\n      let angBtw = Math.atan2(connections[i].to.y - connections[i].from.y,\r\n        connections[i].to.x - connections[i].from.x);\r\n      // angBtw += K.PI;\r\n      ctx.save();\r\n      ctx.lineWidth = hoveringConn == connections[i]?K.LINEACCEPTDIST:K.LINEWIDTH;\r\n      ctx.lineCap = \"square\";\r\n      if (!hoveringConn || hoveringConn == connections[i])\r\n        ctx.strokeStyle = connections[i].colour;\r\n      else if (hoveringConn)\r\n        ctx.strokeStyle = connections[i].colour+\"55\";\r\n      // else \r\n      // ctx.strokeStyle = hoveringConn == connections[i]?connections[i].colour+\"55\":connections[i].colour;\r\n      ctx.beginPath();\r\n      let c = Math.cos(angBtw);\r\n      let s = Math.sin(angBtw);\r\n      // let newAng = angBtw;\r\n      ctx.moveTo(connections[i].from.x + c * stopSz + offset.x,\r\n        connections[i].from.y + s * stopSz          + offset.y);\r\n      ctx.lineTo(connections[i].to.x - c * stopSz   + offset.x,\r\n        connections[i].to.y - s * stopSz            + offset.y)\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    }\r\n  \r\n    ctx.save();\r\n    ctx.lineWidth = 4;\r\n    //////// current path /////////\r\n    // connect(currPath, getCSSProp(\"--system-green\"));\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = defaultClr;\r\n    ctx.stroke();\r\n    for (let i = 1; i < currPath.length; i++) {\r\n      let angBtw = Math.atan2(currPath[i].y - currPath[i - 1].y,\r\n        currPath[i].x - currPath[i - 1].x);\r\n      ctx.beginPath();\r\n      let c = Math.cos(angBtw);\r\n      let s = Math.sin(angBtw);\r\n      ctx.strokeStyle = getCSSProp(\"--system-\" + colours[0]);\r\n      ctx.lineWidth = K.LINEWIDTH;\r\n      ctx.moveTo(currPath[i - 1].x + c * acceptRadius, currPath[i - 1].y + s * acceptRadius);\r\n      ctx.lineTo(currPath[i].x - c * acceptRadius, currPath[i].y - s * acceptRadius)\r\n      ctx.stroke();\r\n      ctx.strokeStyle = defaultClr;\r\n    }\r\n    ctx.lineWidth = 4;\r\n    ctx.beginPath();\r\n  \r\n  \r\n    //////////////// existing path line circles ////////////////////\r\n    for (let i = 0; i < connections.length; i++) {\r\n      // ctx.strokeStyle = getCSSProp(\"--\")\r\n      clearCircle(connections[i].from, stopSz);\r\n      clearCircle(connections[i].to, stopSz);\r\n      ctx.beginPath();\r\n      // ctx.lineWidth = K.LINEWIDTH;      \r\n      ctx.strokeStyle = defaultClr;\r\n      ctx.arc(connections[i].from.x, connections[i].from.y, stopSz, 0, K.PI * 2);\r\n      ctx.stroke();\r\n      ctx.beginPath();\r\n      ctx.arc(connections[i].to.x, connections[i].to.y, stopSz, 0, K.PI * 2);\r\n      ctx.stroke();\r\n      // circle(connections[i].from)//, connections[i].colour);\r\n      // circle(connections[i].to) //, connections[i].colour);\r\n    }\r\n    ctx.restore();\r\n    ctx.beginPath();\r\n    ////////////////////////////////\r\n    ctx.restore();\r\n    ctx.beginPath();\r\n    if (holdState == K.HOLD_NEWLINE) {\r\n      // must have a starting poibt\r\n      let lastPt = currPath[currPath.length - 1];\r\n      let angBtw = Math.atan2(currPos_canv.y - lastPt.y,\r\n        currPos_canv.x - lastPt.x);\r\n      let c = Math.cos(angBtw);\r\n      let s = Math.sin(angBtw);\r\n      let nextStop = nearestStop(currPos_canv, acceptRadius);\r\n      if (nextStop && samePt(nextStop, lastPt)) { // accepted new stop\r\n        clearCircle(lastPt, acceptRadius);\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.lineWidth = 4;\r\n        ctx.strokeStyle = getCSSProp(\"--system-\" + colours[0]);\r\n        ctx.arc(lastPt.x, lastPt.y, stopSz, 0, K.PI * 2);\r\n        ctx.stroke();\r\n        circle(lastPt);\r\n        ctx.restore();\r\n  \r\n      }\r\n      ctx.beginPath();\r\n      // else if (!nextStop) {\r\n      if (nextStop && samePt(nextStop, lastPt)); // return;\r\n      // THERE'S A PROBLEM.\r\n      else if (nextStop) {\r\n  \r\n        angBtw = Math.atan2(nextStop.y - lastPt.y,\r\n          nextStop.x - lastPt.x);\r\n        c = Math.cos(angBtw);\r\n        s = Math.sin(angBtw);\r\n        ctx.moveTo(lastPt.x + c * acceptRadius, lastPt.y + s * acceptRadius);\r\n  \r\n        ctx.save();\r\n        ctx.strokeStyle = getCSSProp(\"--system-\" + colours[0]);\r\n        ctx.lineWidth = K.LINEWIDTH;\r\n        ctx.lineTo(nextStop.x - c * acceptRadius, nextStop.y - s * acceptRadius);\r\n        ctx.stroke();\r\n        ctx.beginPath();\r\n        ctx.lineWidth = 4;\r\n        ctx.strokeStyle = getCSSProp(\"--system-red\");\r\n        ctx.arc(nextStop.x, nextStop.y, stopSz, 0, K.PI * 2);\r\n        ctx.stroke();\r\n        circle(nextStop);\r\n        ctx.restore();\r\n      }\r\n      // just not connected yet.\r\n      else {\r\n        ctx.moveTo(lastPt.x + c * acceptRadius, lastPt.y + s * acceptRadius);\r\n        ctx.save();\r\n        ctx.strokeStyle = getCSSProp(\"--system-\" + colours[0]);\r\n        ctx.lineWidth = K.LINEWIDTH;\r\n        ctx.lineTo(currPos_canv.x, currPos_canv.y);\r\n        ctx.stroke();\r\n        ctx.restore();\r\n      }\r\n  \r\n      //////////////// then put the current path large circles /////////\r\n      for (let i = 0; i < currPath.length; i++) {\r\n        ctx.save();\r\n        ctx.strokeStyle = getCSSProp(\"--system-\" + colours[0]);\r\n        circle(currPath[i]);\r\n        ctx.restore();\r\n      }\r\n      // if (!samePt(nextStop, lastPt)) \r\n      //   ctx.strokeStyle = getCSSProp(\"--system-red\");\r\n      // else \r\n      // ctx.strokeStyle = getCSSProp(\"--system-green\");\r\n  \r\n      // }\r\n    }\r\n    for (let i = 0; i < stops.length; i++)\r\n      ctx.fillText(stops[i].type, stops[i].x, stops[i].y)\r\n    // now we draw the trains!\r\n    for (let i = 0; i < trains.length; i++) {\r\n      ctx.beginPath();\r\n      let angBtw = Math.atan2(trains[i].to.y - trains[i].from.y,\r\n        trains[i].to.x - trains[i].from.x);\r\n      let nStop = nearestStop(trains[i], stopSz);\r\n      // if (!nStop) nStop = nearestStop(trains[i].from, stopSz);\r\n  // angBtw = 0;\r\n      let associatedConnection = getAssociatedConnection(trains[i]);\r\n      let offset = handleOffset(associatedConnection);\r\n      let center = { x: trains[i].x+offset.x, y: trains[i].y+offset.y };\r\n      // if (nStop) {\r\n      //   let pctRemaining = distBtw(nStop, trains[i])/(stopSz-15);\r\n      //   let nextTrainTo = getNextStop(trains[i], false);\r\n      //   let movingAway = !samePt(nStop, trains[i].to);\r\n      //   let angBtw2 = Math.atan2(trains[i].to.y - nextTrainTo.y,\r\n      //       trains[i].to.x - nextTrainTo.x);\r\n      //   if (movingAway) {\r\n      //     trains[i].revDir = !trains[i].revDir;\r\n         \r\n      //     let savedTo = trains[i].to;\r\n      //     let savedFrom = trains[i].from;\r\n      //     let nextTrainTo = getNextStop(trains[i], false);\r\n      //     trains[i].to = nextTrainTo;\r\n      //     trains[i].from = savedTo;\r\n      //     nextTrainTo = getNextStop(trains[i], false);\r\n      //     trains[i].to = savedTo;\r\n      //     trains[i].from = savedFrom;\r\n      //     trains[i].revDir = !trains[i].revDir;\r\n      //     angBtw2 = Math.atan2(trains[i].from.y -nextTrainTo.y,\r\n      //       trains[i].from.x - nextTrainTo.x); \r\n      //   }\r\n      //   // x'(t) = x1 + 2*x2*t + 3*x3*t*t\r\n      //   // y'(t) = y1 + 2*y2*t + 3*y3*t*t\r\n      //   // let ctrlPt1 = {}\r\n      //   if (pctRemaining < 1) {\r\n          \r\n      //     let pct = samePt(nStop, trains[i].to)?pctRemaining:(1-pctRemaining);\r\n      //     center.x = bezier(pct, nStop.x+Math.cos(angBtw2+K.PI)*stopSz, nStop.x, nStop.x+Math.cos(angBtw+K.PI)*stopSz);\r\n      //     center.y = bezier(pct, nStop.y+Math.sin(angBtw2+K.PI)*stopSz, nStop.y, nStop.y+Math.sin(angBtw+K.PI)*stopSz);\r\n      //     ctx.beginPath();\r\n      //     ctx.moveTo(nStop.x+Math.cos(angBtw2+Math.PI)*stopSz, nStop.y+Math.sin(angBtw2+Math.PI)*stopSz);\r\n      //     ctx.lineTo(nStop.x, nStop.y);\r\n      //     ctx.lineTo(nStop.x+Math.cos(angBtw+Math.PI)*stopSz, nStop.y+Math.sin(angBtw+Math.PI)*stopSz);\r\n      //     ctx.stroke();\r\n      //     // ctx.beginPath();\r\n      //     let delta = angBtw2-angBtw;\r\n      //     angBtw = angBtw+delta*(1-pctRemaining);\r\n      //       // x1 = 2*xc - x0/2 - x2/2\r\n      //      // y1 = 2*yc - y0/2 - y2/2\r\n      //   }\r\n      //   // at stop, turn according to distance\r\n      // } // if nstop\r\n      const w = 15;\r\n      const h = 30;\r\n      const c = Math.cos(angBtw);\r\n      const c2 = Math.cos(angBtw + K.PI / 2)\r\n      const s = Math.sin(angBtw);\r\n      const s2 = Math.sin(angBtw + K.PI / 2);\r\n      // const halfDiag = Math.sqrt(w*w/4+h*h/4)/2;\r\n      ctx.save();\r\n      // ctx.translate(-center.x, -center.y)\r\n      // ctx.rotate(angBtw);\r\n      // ctx.translate(center.x, center.y);\r\n      ctx.globalAlpha = 0.6;\r\n      ctx.fillStyle = associatedConnection.colour;\r\n      ctx.moveTo(center.x + c * h / 2 + c2 * w / 2, center.y + s * h / 2 + s2 * w / 2);\r\n      ctx.lineTo(center.x + c * h / 2 - c2 * w / 2, center.y + s * h / 2 - s2 * w / 2);\r\n      ctx.lineTo(center.x - c * h / 2 - c2 * w / 2, center.y - s * h / 2 - s2 * w / 2);\r\n      ctx.lineTo(center.x - c * h / 2 + c2 * w / 2, center.y - s * h / 2 + s2 * w / 2);\r\n      ctx.fill();\r\n      ctx.fillStyle = defaultClr;\r\n      let str = \"\";\r\n      for (let pass of trains[i].passengers)\r\n        str+= pass.to.toString();\r\n      ctx.save();\r\n      /// here coems the transformation!\r\n      ctx.globalAlpha = 1;\r\n      ctx.translate(center.x, center.y);\r\n      ctx.beginPath();\r\n      ctx.rotate(angBtw+(trains[i].revDir?Math.PI:0));\r\n      let y = 0;\r\n      ctx.textAlign = \"center\";\r\n      ctx.textBaseline = \"middle\";\r\n      let uSz = w/2;\r\n      let cap = trains[i].cap;\r\n      for (let j=0; j<trains[i].passengers.length; j++) {\r\n        if (j>=cap/2) y = 1;\r\n        \r\n        ctx.fillText(trains[i].passengers[j].to, j%(cap/2)*uSz+uSz/2-h/2, y*uSz+uSz/2-w/2);\r\n        \r\n      }\r\n      // ctx.moveTo(-w/2, -h/2);\r\n      // ctx.lineTo(w/2, h/2);\r\n      // ctx.stroke();\r\n      ctx.beginPath();\r\n      ctx.restore();\r\n      // ctx.fillText(str, center.x, center.y)\r\n      // ctx.fillRect(center.x - 8, center.y-2.5, 16, 5);\r\n      ctx.restore();\r\n    }\r\n    \r\n  }\r\n  \r\n  function registerMaximisingCanvas(id, widthPc, heightPc, redrawFcn) { // (id:string, widthPc:number, heightPc:number, redrawFcn:()=>any) {\r\n    //let canv = byId(id)// as HTMLCanvasElement;\r\n    window.addEventListener(\"resize\", (ev) => {\r\n      canv.width = window.innerWidth * widthPc;\r\n      canv.height = window.innerHeight * heightPc;\r\n      // everything is gone - restore it!\r\n      applyTransfm();\r\n      redrawFcn();\r\n    })\r\n    canv.style.height = 100 * heightPc + \"vh\";\r\n    canv.style.width = 100 * widthPc + \"vw\";\r\n    canv.width = window.innerWidth * widthPc;\r\n    canv.height = window.innerHeight * heightPc;\r\n    redrawFcn();\r\n  }\r\n  \r\n  function populateStops() {\r\n    for (let i = 0; i < stops.length; i++) {\r\n      if (Math.random() < 0.4) continue;\r\n      let toAdd = Math.floor(Math.random() * (stops.length) / 3) + 1;\r\n      for (let j = 0; j < toAdd; j++) {\r\n        let stopAdded = Math.floor(Math.random() * stops.length);\r\n        // if (stopAdded >= stops[i].type) stopAdded++;\r\n        let currType = getNextType(stops[stopAdded].type);\r\n        let pass = { from: stops[stopAdded], to: currType, route: [], \r\n                    status: K.WAITING, actionStatus: K.NOACTION, train:null, stop:null};\r\n        passengers.push(pass);\r\n        handlePassenger(pass);\r\n        stops[stopAdded].waiting.push(pass);\r\n        let stop = stops[stopAdded]\r\n        if (stop.waiting.length > stop.capacity && stop.failureTimer < 0)\r\n          stop.failureTimer = Date.now();\r\n          \r\n      }\r\n    }\r\n  }\r\n  \r\n  function preLoad() {\r\n    canv = byId(\"canv\");\r\n    ctx = canv.getContext(\"2d\");\r\n    registerMaximisingCanvas(\"canv\", 1, 0.95, redraw);\r\n    if ((docURL.searchParams.get(\"debug\")??\"yesplease\").match(/false|no|beans/)) {\r\n      DEBUG = false;\r\n    }\r\n    canv.addEventListener(\"pointermove\", onmove);\r\n    canv.addEventListener(\"pointerdown\", (ev) => {\r\n      if (event.button != 0) return;\r\n      holdState = K.HOLD;\r\n      downPt = { x: ev.clientX, y: ev.clientY };\r\n      let actualPos = fromCanvPos(ev.clientX, ev.clientY);\r\n      let nStop = nearestStop(actualPos, acceptRadius);\r\n      if (nStop && colours.length > 0) {\r\n        holdState = K.HOLD_NEWLINE;\r\n        currPath = [nStop];\r\n        redraw();\r\n      }\r\n      if (holdState == K.HOLD) {\r\n        document.body.style.cursor = \"grabbing\";\r\n      }\r\n    });\r\n    window.addEventListener(\"keydown\", keyUpdate);\r\n    window.addEventListener(\"keyup\", keyUpdate);\r\n    window.addEventListener(\"pointerup\", routeConfirm);\r\n    canv.addEventListener(\"wheel\", (ev) => {\r\n      // larger -ve deltaY: \r\n      // ctx.\r\n      // let sclFac = (ev.deltaY<0?Math.pow(10, -ev.deltaY/750):Math.pow(10, -ev.deltaY/400))\r\n      let sclFac = (ev.deltaY < 0 ? 1.15 : 1 / 1.15)\r\n      if (sclFac * totalScaleFac > maxSclFac)\r\n        sclFac = maxSclFac / totalScaleFac;\r\n      if (sclFac * totalScaleFac < minSclFac)\r\n        sclFac = minSclFac / totalScaleFac;\r\n      translate(-ev.clientX, -ev.clientY);\r\n      scale(sclFac);\r\n      translate(ev.clientX, ev.clientY);\r\n      totalScaleFac *= sclFac;\r\n      redraw();\r\n    })\r\n    //////////\r\n    // setup stops\r\n    updateMinScl();\r\n    // let firstPoint = genRandomPt();\r\n    // firstPoint.waiting = [];\r\n    // stops.push(firstPoint);\r\n    // stops.type = 0;\r\n    // let canvMinDim = Math.min(viewportW, viewportH); \r\n    for (let i = 0; i < 3; i++) {\r\n      addNewStop(i);\r\n    }\r\n    totalScaleFac *= 0.8;\r\n    // translate(-viewportW/2, -viewportH/2);\r\n    redraw();\r\n    scale(totalScaleFac);\r\n    redraw();\r\n    translate(canv.width / 2, canv.height / 2);\r\n    redraw();\r\n    //////\r\n    // setInterval(animLoop, 1000/60);\r\n    requestAnimationFrame(animLoop);\r\n    startTime = Date.now();\r\n    setTimeout(stopPopulationLoop, 5000);\r\n  }\r\n  \r\n  function nearestConnection(x, y) {\r\n    let bestDist = K.INF;\r\n    let bestConn = null;\r\n    for (let i=0; i<connections.length; i++) {\r\n      let cn = connections[i];\r\n      let off = handleOffset(cn);\r\n      // let tOff = handleOffset(cn.to);\r\n      let currDist = pDist(x, y, cn.from.x+off.x, cn.from.y+off.y, cn.to.x+off.x, cn.to.y+off.y);\r\n      if (currDist < bestDist) {\r\n        bestDist = currDist;\r\n        bestConn = cn;\r\n      }\r\n    }\r\n    // return bestConn;\r\n    return bestDist < K.LINEACCEPTDIST?bestConn:null;\r\n  }\r\n  \r\n  // thanks https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment#1501725\r\n  // love not writing my own code\r\n  function pDist(x, y, x1, y1, x2, y2) { // dist between line SEGMENT and pt\r\n  \r\n    var A = x - x1;\r\n    var B = y - y1;\r\n    var C = x2 - x1;\r\n    var D = y2 - y1;\r\n  \r\n    var dot = A * C + B * D;\r\n    var len_sq = C * C + D * D;\r\n    var param = -1;\r\n    if (len_sq != 0) //in case of 0 length line\r\n        param = dot / len_sq;\r\n  \r\n    var xx, yy;\r\n  \r\n    if (param < 0) {\r\n      xx = x1;\r\n      yy = y1;\r\n    }\r\n    else if (param > 1) {\r\n      xx = x2;\r\n      yy = y2;\r\n    }\r\n    else {\r\n      xx = x1 + param * C;\r\n      yy = y1 + param * D;\r\n    }\r\n  \r\n    var dx = x - xx;\r\n    var dy = y - yy;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n  \r\n  function animLoop() {\r\n    for (let i = 0; i < trains.length; i++) {\r\n      let currTrain = trains[i];\r\n      let distTotal = distBtw(trains[i].to, trains[i].from);\r\n      // distToCover = s * px/s / px\r\n      let distTravelled = (Date.now() - currTrain.startT) * trainSpeed;\r\n      let percentCovered = distTravelled / distTotal;\r\n      if (percentCovered < 0) continue;\r\n      if (percentCovered >= 1) { // at a stop. \r\n        let startT = Date.now();\r\n        percentCovered = 0;\r\n        // let applicable = [];\r\n        let currentTo = trains[i].to;//trains[i].revDir?trains[i].from:trains[i].to;\r\n        let currStop = nearestStop(currentTo, 1);\r\n        // currTrain.onCompletion = currTrain.passengers.length;\r\n        // how many people to drop off here?\r\n        let delay = dropOff(currTrain, currentTo) * K.DELAYPERPASSENGER;\r\n        // figure out if the train is due to reverse first.\r\n        let reverseQ = true;\r\n        let nextStop = null;\r\n        // for (let j = 0; j < connections.length && reverseQ; j++) {\r\n        //   if ((trains[i].revDir ? samePt(connections[j].to, currentTo)\r\n        //     : samePt(connections[j].from, currentTo))\r\n        //     && connections[j].lineID == trains[i].lineID) {\r\n        //     reverseQ = false;\r\n        //     nextStop = trains[i].revDir ? connections[j].from : connections[j].to;\r\n        //   }\r\n        // }\r\n        // no need to do all this nonsense the train knows its path\r\n         nextStop = getNextStop(currTrain);   \r\n        // who to pick up?\r\n        //  find which stops this line supports\r\n        // let availableTransfers = new Set();\r\n        \r\n        // while (true) {\r\n        currStop = nearestStop(currentTo, 1);\r\n        let upcomingLinesServed = new Set(JSON.parse(JSON.stringify([...currStop.linesServed])));\r\n        // 1. drop off people who are transferring - MAKE SURE THEY'RE ON THEIR WAY!\r\n        for (let j=0; j<currTrain.passengers.length; j++) {\r\n          let pass = currTrain.passengers[j];\r\n          if (pass.route.length > 0 && pass.status == K.ONTHEWAY \r\n              && pass.actionStatus == K.NOACTION &&\r\n              upcomingLinesServed.has(pass.route[0])) {\r\n            // currTrain.passengers.splice(j, 1);\r\n            // currStop.toAdd.push({from:currTrain,pass:pass});\r\n            // currTrain.onCompletion--;\r\n            // // currStop.waiting.push(pass);\r\n            // // debugger;\r\n            // // j--;\r\n            pass.actionStatus = K.TRANSFERPENDING;\r\n            // pass.status = K.WAITING;\r\n            pass.stop = currStop;\r\n            pass.train = currTrain;\r\n            pass.route.shift();\r\n            delay += K.DELAYPERPASSENGER;\r\n          }\r\n        }\r\n        // 2. pick up people who need transfers (they typically wait very long)\r\n        for (let j=0; j<connections.length; j++) {\r\n          if (connections[j].lineID == currTrain.lineID) {\r\n            let fStop = nearestStop(connections[j].from, 1);\r\n            let tStop = nearestStop(connections[j].to, 1);\r\n            for (const nextLine of fStop.linesServed) \r\n              upcomingLinesServed.add(nextLine);\r\n            for (const nextLine of tStop.linesServed) \r\n              upcomingLinesServed.add(nextLine);\r\n          }\r\n        }\r\n        for (let j=0; j<currStop.waiting.length; j++) {\r\n          let pass = currStop.waiting[j];\r\n          // if (currTrain.onCompletion >= currTrain.cap) break;\r\n          if (currStop.waiting[j].actionStatus != K.NOACTION) continue;\r\n          if (pass.route.length > 0 && upcomingLinesServed.has(pass.route[0])) {\r\n            // currStop.waiting.splice(j, 1);\r\n            currStop.waiting[j].actionStatus = K.BOARDPENDING;\r\n            // pass.status = K.ONTHEWAY;\r\n            currStop.waiting[j].stop = currStop;\r\n            currStop.waiting[j].train = currTrain;\r\n            // j--;\r\n            // currTrain.onCompletion++;\r\n            // currTrain.toAdd.push({stop:currStop,pass:pass});\r\n            // pass.status = K.ONTHEWAY;\r\n            delay += K.DELAYPERPASSENGER;\r\n          }\r\n        }\r\n          \r\n        // 3. pick up people who do not have transfers at all\r\n        for (let k = 0; k < currStop.waiting.length; k++) {\r\n          // if (currTrain.passengers.length >= currTrain.cap) break;\r\n          // for (let j = 0; j < typesOnLine.length; j++) {\r\n  \r\n          if (currStop.waiting[k].actionStatus != K.NOACTION) continue;\r\n          if (typesOnLine[currTrain.lineID].has(currStop.waiting[k].to)) {\r\n            let adding = currStop.waiting[k];\r\n            currStop.waiting[k].actionStatus = K.BOARDPENDING;\r\n            currStop.waiting[k].stop = currStop;\r\n            currStop.waiting[k].train = currTrain;\r\n            // adding.status = K.ONTHEWAY;\r\n            // currStop.waiting.splice(k, 1);\r\n            // currTrain.toAdd.push({stop:currStop,pass:adding});\r\n            // k--;\r\n          }\r\n          delay += K.DELAYPERPASSENGER;\r\n          // }\r\n        }\r\n        // if (currTrain.revDir) {\r\n        if (delay > 0) currTrain.startT = K.INF;\r\n        handleAwaiting(currTrain, currStop);\r\n        currTrain.from = currTrain.to;\r\n        currTrain.to = nextStop;\r\n        \r\n        // }\r\n        if (Date.now() - startT > 25) \r\n          console.log(\"WARNING: StopHandler took \", Date.now() - startT+\"ms\");\r\n      } // if percentcoered = 1\r\n      currTrain.x = currTrain.from.x + (currTrain.to.x - currTrain.from.x) * percentCovered;\r\n      currTrain.y = currTrain.from.y + (currTrain.to.y - currTrain.from.y) * percentCovered;\r\n    }\r\n    for (let i=0; i<stops.length; i++) {\r\n      if (stops[i].failureTimer < 0) continue;\r\n      let pctRemaining = (Date.now() - stops[i].failureTimer)/K.FAILTIME;\r\n      if (pctRemaining > 1.1) {\r\n        alertDialog(\"loser!\", ()=>{\r\n          location.reload();\r\n        });\r\n        return;\r\n      }\r\n    }\r\n    redraw();\r\n  \r\n    requestAnimationFrame(animLoop);\r\n  }\r\n  \r\n  function handleAwaiting(currTrain, currStop) {\r\n    let handled = false;\r\n    for (const pass of passengers) {\r\n      if (pass.train != currTrain || pass.stop != currStop) continue;\r\n      else if (pass.actionStatus == K.NOACTION) continue;\r\n      // if people are trying to get on the train but unable to do so - abandon the action and wait for next recalculation\r\n      else if (currTrain.passengers.length >= currTrain.cap && \r\n               pass.actionStatus == K.BOARDPENDING) {\r\n        pass.actionStatus = K.NOACTION;\r\n        continue;\r\n      }\r\n      else if (pass.actionStatus == K.BOARDPENDING) {\r\n        pass.actionStatus = K.NOACTION;\r\n        for (let i=0; i<currStop.waiting.length; i++) \r\n          if (currStop.waiting[i] == pass) {\r\n            currStop.waiting.splice(i, 1);\r\n            currTrain.passengers.push(pass);\r\n            break;\r\n          }\r\n        if (currStop.waiting.length < currStop.capacity)\r\n          currStop.failureTimer = -1;\r\n        pass.status = K.ONTHEWAY;\r\n        pass.actionStatus = K.NOACTION;\r\n        handled = true;\r\n        break;\r\n      }\r\n      else if (pass.actionStatus == K.DEBOARDPENDING) {\r\n        pass.actionStatus = K.NOACTION;\r\n        for (let i=0; i<currTrain.passengers.length; i++) \r\n          if (currTrain.passengers[i] == pass) {\r\n            currTrain.passengers.splice(i,1);\r\n            break;\r\n          }\r\n        pass.status = K.WAITING;\r\n        if (currStop.waiting.length < currStop.capacity)\r\n          currStop.failureTimer = -1;\r\n        pass.actionStatus = K.NOACTION;\r\n        handled = true;\r\n        break;\r\n      }\r\n      else if (pass.actionStatus == K.TRANSFERPENDING) {\r\n        pass.actionStatus = K.NOACTION;\r\n        for (let i=0; i<currTrain.passengers.length; i++) \r\n          if (currTrain.passengers[i] == pass) {\r\n            currTrain.passengers.splice(i,1);\r\n            currStop.waiting.push(pass);\r\n            break;\r\n          }\r\n        pass.status = K.WAITING;\r\n        pass.actionStatus = K.NOACTION;\r\n        let stop = currStop;\r\n        if (stop.waiting.length > stop.capacity && stop.failureTimer < 0)\r\n          stop.failureTimer = Date.now();\r\n        handled = true;\r\n        break;\r\n      }\r\n      else throw(\"invalid actionStatus!\");\r\n    }\r\n    if (handled) setTimeout(()=>{handleAwaiting(currTrain, currStop)}, K.DELAYPERPASSENGER);\r\n    else {\r\n      currTrain.startT = Date.now();\r\n    }\r\n  }\r\n  \r\n  function dropOff(currTrain, pt) {\r\n    let stop = nearestStop(pt, 1);\r\n    let matching = 0;\r\n    for (let i = 0; i < currTrain.passengers.length; i++)\r\n      if (currTrain.passengers[i].to == stop.type && currTrain.passengers[i].actionStatus == K.NOACTION) {\r\n        matching++;\r\n        // currTrain.passengers.splice(i, 1);\r\n        // currTrain.onCompletion--;\r\n        currTrain.passengers[i].actionStatus = K.DEBOARDPENDING;\r\n        currTrain.passengers[i].stop = stop;\r\n        currTrain.passengers[i].train = currTrain;\r\n        // currTrain.toRemove.push({stop:stop, pass:currTrain.passengers[i]});\r\n        // i--;\r\n      }\r\n    return matching;\r\n  }\r\n  \r\n  function stopPopulationLoop() {\r\n    populateStops();\r\n    redraw();\r\n    setTimeout(stopPopulationLoop, 5000 + Math.random() * 7000);\r\n  }\r\n  \r\n  function updateMinScl(newVal = minSclFac) {\r\n    minSclFac = newVal;\r\n    viewportW = canv.width / minSclFac * 0.4;\r\n    viewportH = canv.height / minSclFac * 0.4;\r\n    viewportMax = Math.max(viewportW, viewportH);\r\n    viewportMin = Math.min(viewportW, viewportH);\r\n  }\r\n  \r\n  function addNewStop(type = -1) {\r\n    let newPt;\r\n    if (type < 0) type = getNextType();\r\n    if (stops.length > 0)\r\n      do {\r\n        // newPt = genRandomPt();\r\n        // this is stupid.\r\n        refPt = stops[Math.floor(Math.random() * stops.length)];\r\n        // if (refPt)\r\n        ang = Math.random() * 2 * K.PI;\r\n        dist = 150 + Math.random() * 100\r\n        newPt = { x: refPt.x + dist * Math.cos(ang), y: refPt.y + dist * Math.sin(ang) };\r\n      } while (!(!nearestStop(newPt, 150) && withinViewport(newPt)));\r\n    else newPt = genRandomPt();\r\n    stops.push(newPt);\r\n    maxUnlockedType = Math.max(maxUnlockedType, type);\r\n    updateMinScl(minSclFac * 0.98);\r\n    newPt.waiting = [];\r\n    newPt.linesServed = new Set();\r\n    newPt.type = type;\r\n    newPt.toAdd = [];\r\n    newPt.failureTimer = -1;\r\n    newPt.capacity = 6;\r\n    redraw();\r\n  }\r\n  \r\n  function keyUpdate(ev) {\r\n    // if (!shiftStatus && ev.shiftKey)\r\n    //   document.body.style.cursor = \"grab\";\r\n    // else if (shiftStatus && !ev.shiftKey) \r\n    //   document.body.style.cursor = \"\";\r\n    // shiftStatus = ev.shiftKey;\r\n  }\r\n  \r\n  function onmove(ev) {\r\n    // if (ev.shiftKey) {\r\n    //   document.body.style.cursor = \"grabbing\";\r\n    // }\r\n    hovering = null;\r\n    hoveringConn = null;\r\n    currPos_canv = fromCanvPos(ev.clientX, ev.clientY);\r\n    // let \r\n    if (holdState == K.HOLD) {// && ev.shiftKey) {\r\n      translate(ev.movementX, ev.movementY);\r\n      redraw();\r\n    }\r\n    let actualPos = fromCanvPos(ev.clientX, ev.clientY);\r\n    // console.log()\r\n    let nConn = nearestConnection(actualPos.x, actualPos.y);\r\n    let nStop = nearestStop(actualPos, acceptRadius);\r\n    if (holdState == K.HOLD_NEWLINE) {\r\n      \r\n      let lastStop = currPath[currPath.length - 1];\r\n      // if (!nStop) // \r\n      //   currPath.pop();\r\n      if (nStop) {\r\n        let canAdd = true;\r\n        for (let i = 0; i < currPath.length && canAdd; i++) {\r\n          if (samePt(currPath[i], nStop)) canAdd = false;\r\n        }\r\n        if (!canAdd && currPath.length > 2\r\n          && samePt(nStop, currPath[0]) && !samePt(nStop, lastStop)) {\r\n          currPath.push(nStop);\r\n          routeConfirm();\r\n          // holdState = K.NOHOLD;\r\n        }\r\n        if (canAdd) {\r\n          currPath.push(nStop);\r\n        }\r\n      }\r\n      redraw();\r\n    }\r\n    else if (nStop) {\r\n      hovering = nStop;\r\n      document.body.style.cursor = \"pointer\";\r\n    }\r\n    else if (nConn) {\r\n      console.log(nConn);\r\n      hoveringConn = nConn;\r\n      document.body.style.cursor = \"pointer\";\r\n    }\r\n    else if (holdState == K.NOHOLD) document.body.style.cursor = \"\";\r\n  }\r\n  \r\n  function routeConfirm(ev) {\r\n    holdState = K.NOHOLD;\r\n    document.body.style.cursor = holdState == K.HOLD ? \"grab\" : \"\";\r\n    if (currPath.length > 1) {\r\n      let currCol = getCSSProp(\"--system-\" + colours[0]);\r\n      colours.shift();\r\n      // lines.push({path:currPath, \r\n      // colour:getCSSProp(\"--system-\"+colours[lines.length])});\r\n      for (let i = 1; i < currPath.length; i++) {\r\n        connections.push({\r\n          from: currPath[i - 1], to: currPath[i],\r\n          colour: currCol, lineID: lineCt\r\n        });\r\n      }\r\n      // run dijkstra?\r\n      let currLine = [];\r\n      for (const e of currPath) {\r\n        currLine.push(e);\r\n      }\r\n      lines.push({lineID:lineCt, path:currLine, loopingQ:(currPath[0] == currPath[currPath.length-1])});\r\n  \r\n      let supportedTypes = new Set();\r\n      for (let i = 0; i < currPath.length; i++) {\r\n        supportedTypes.add(currPath[i].type);\r\n        currPath[i].linesServed.add(lineCt);\r\n      }\r\n      typesOnLine.push(supportedTypes);\r\n      // for ()\r\n      /// now every passenger route will be affected\r\n      // for (let currP of passengers) {\r\n      // if (currP.status != K.WAITING) continue;\r\n      adj = [];\r\n      for (let i = 0; i < typesOnLine.length; i++) {\r\n        let row = [];\r\n        for (let j = 0; j < typesOnLine.length; j++) {\r\n          row.push({ route:[], val: K.INF });\r\n        }\r\n        adj.push(row);\r\n      }\r\n      for (let i = 0; i < stops.length; i++) {\r\n        let served = Array.from(stops[i].linesServed);\r\n        for (let j = 0; j < served.length; j++) {\r\n          for (let k = 0; k < served.length; k++) {\r\n            adj[served[j]][served[k]].val = 1;\r\n            adj[served[j]][served[k]].route = [served[k]];\r\n            adj[served[k]][served[j]].val = 1;\r\n            adj[served[k]][served[j]].route = [served[j]];\r\n          }\r\n        }\r\n        for (let j=0; j<served.length; j++) {\r\n          adj[served[j]][served[j]].val = 0;\r\n          adj[served[j]][served[j]].route = [];\r\n        }\r\n      }\r\n      for (let k = 0; k < adj.length; k++) {\r\n        for (let j = 0; j < adj.length; j++) {\r\n          for (let i = 0; i < adj.length; i++) {\r\n            if (i == k || j == k) continue;\r\n            let newCost = adj[i][k].val+adj[k][j].val;\r\n            if (newCost < adj[i][j].val) {\r\n              adj[i][j].val = newCost;\r\n              adj[i][j].route = [];\r\n              \r\n              // let replaceIdx = adj[i][j].indexOf(i);\r\n              for (let n=0; n<adj[i][k].route.length; n++) \r\n                adj[i][j].route.push(adj[i][k].route[n])\r\n              for (let n=0; n<adj[k][j].route.length; n++) \r\n                adj[i][j].route.push(adj[k][j].route[n])\r\n            }\r\n            // adj[i][j].val = Math.min(adj[i][j].val, adj[i][k].val + adj[k][j].val);\r\n          }\r\n        }\r\n        \r\n      }\r\n      console.log(\"==== RECALCULATION SUCCESS ====\")\r\n      for (pass of passengers) {\r\n        handlePassenger(pass);\r\n      }\r\n      trains.push({\r\n        x: currPath[0].x, y: currPath[0].y,\r\n        from: currPath[0], to: currPath[1], path: currPath,\r\n        lineID: lineCt, colour: currCol, startT: Date.now(),\r\n        status: K.MOVING, passengers: [], cap:6, revDir:false, \r\n        //toAdd:[], toRemove:[], onCompletion:0\r\n      });\r\n      trains.push({\r\n        x: currPath[0].x, y: currPath[0].y,\r\n        from: currPath[currPath.length-1], to: currPath[currPath.length-2], path: currPath,\r\n        lineID: lineCt, colour: currCol, startT: Date.now(),\r\n        status: K.MOVING, passengers: [], cap:6, revDir:true,//, toAdd:[], toRemove:[], \r\n        //onCompletion:0\r\n      });\r\n      lineCt++;\r\n    }\r\n    currPath = [];\r\n    redraw();\r\n    if (!ev || !downPt || distBtw({ x: ev.clientX, y: ev.clientY }, downPt) > 10) return;\r\n    // check for is it actually a click ^\r\n    ctx.beginPath();\r\n    let actualPos = fromCanvPos(ev.clientX, ev.clientY);\r\n    ctx.moveTo(actualPos.x - 0.5, actualPos.y - 0.5);\r\n    ctx.lineTo(actualPos.x + 0.5, actualPos.y + 0.5);\r\n    ctx.stroke();\r\n    ctx.fillText(actualPos.x.toFixed(2) + \", \" + actualPos.y.toFixed(2), actualPos.x, actualPos.y);\r\n  }\r\n  \r\n  function samePt(pt1, pt2) {\r\n    return Math.abs(pt1.x - pt2.x) < 0.1 && Math.abs(pt1.y - pt2.y) < 0.1;\r\n  }\r\n  \r\n  function genRandomPt() {\r\n    return {\r\n      x: Math.random() * viewportW - viewportW / 2,\r\n      y: Math.random() * viewportH - viewportH / 2\r\n    }\r\n  }\r\n  \r\n  function nearestStop(newPt, minDist) {\r\n    let found = null;\r\n    for (let i = 0; i < stops.length; i++) {\r\n      let dist = distBtw(stops[i], newPt);\r\n      if (dist < minDist) {\r\n        found = stops[i];\r\n        minDist = dist;\r\n      }\r\n    }\r\n    return found;\r\n  }\r\n  \r\n  function withinViewport(newPt) {\r\n    // let viewportScl = minSclFac*0.8;\r\n    // should be <1 and decreasing\r\n    if (newPt.x < -viewportW / 2) return false;\r\n    if (newPt.x > viewportW / 2) return false;\r\n    if (newPt.y < -viewportH / 2) return false;\r\n    if (newPt.y > viewportH / 2) return false;\r\n    return true;\r\n  }\r\n  function distBtw(pt1, pt2) {\r\n    function sq(x) { return x * x; }\r\n    return Math.sqrt(sq(pt1.x - pt2.x) + sq(pt1.y - pt2.y));\r\n  }\r\n  /// the matrix stuff :V\r\n  let transfm = [1, 0, 0,\r\n    0, 1, 0];\r\n  function translate(x, y) {\r\n    transfm[2] += x;\r\n    transfm[5] += y;\r\n    applyTransfm();\r\n  }\r\n  function fromCanvPos(canvX, canvY) {\r\n    return { x: (canvX - transfm[2]) / transfm[0], y: (canvY - transfm[5]) / transfm[4] };\r\n  }\r\n  function scale(scl) {\r\n    // matrix mult with [\r\n    // sclX 0\r\n    // 0  sclY\r\n    // 0  0\r\n    for (let i = 0; i < 6; i++) transfm[i] *= scl;\r\n    applyTransfm();\r\n  }\r\n  function applyTransfm() {\r\n    ctx.setTransform(transfm[0], transfm[3], transfm[1], transfm[4], transfm[2], transfm[5]);\r\n  }\r\n  \r\n  function triangle() {\r\n  \r\n  }\r\n  function square() {\r\n  \r\n  }\r\n  function circ() {\r\n  \r\n  }\r\n  function star() {\r\n  \r\n  }\r\n  \r\n  function getNextType(exclude = -1) {\r\n    let type = Math.floor(Math.random() * (exclude < 0 ? types.length : maxUnlockedType));\r\n    if (type >= exclude && exclude >= 0) return type + 1;\r\n    return type;\r\n    // if ()\r\n  }"],
  "mappings": "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",
  "names": ["pass", "nextStop", "dist"]
}
