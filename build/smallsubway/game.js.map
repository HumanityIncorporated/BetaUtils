{
  "version": 3,
  "sources": ["../../smallsubway/game.js"],
  "sourcesContent": ["const K = {\n  /// train statuses, probably.\n  MOVING: 1,\n  STOPPED: 2,\n  // touch action statuses\n  NOHOLD: 0,\n  HOLD: 1,\n  HOLD_NEWLINE: 2,\n  HOLD_CONNECTION:3,\n  HOLD_EXTEND: 4,\n  HOLD_TRAIN: 5,\n  HOLD_ADDTRAIN:6,\n  // passenger status \n  WAITING: 0,\n  ONTHEWAY: 1,\n  // settings dialog - base pixel height per terminal to be handled:\n  SETTINGSHEIGHT: 50,\n  // board/deboard time/passenger\n  DELAYPERPASSENGER: 400,\n  INF: 9e99,\n  /// was supposed to be pi and a bit to make arcs completely touching but it didn't seem to work.\n  PI: Math.PI,\n  // animation times:\n  ANIM_SETTINGSDIALOG: 100,\n\n  // stop over-capacity timeout\n  FAILTIME: 40000, // in ticks (scalable ms)\n  PCTPERTICK: 1/40000,\n  LINEWIDTH:10, // width of one line in base-size pixels \n  LINEACCEPTDIST: 30, // base-size pixels under which line dragging will be accepted\n  // actionStatuses: \n  NOACTION:0,\n  BOARDPENDING:1, // just boarding \n  DEBOARDPENDING:2, // just deboarding\n  TRANSFERPENDING:3, // deboarding FOR TRANSFER.\n  REBOARDREQUIRED:4, // train has been removed, wait for next train\n}\n\nlet paused = false;\nconst trainSpeed = 100 / 1000; // pixels/ms\nlet holdState = K.NOHOLD;\nlet activeSettingsDialog = null;\nlet ctx = null;\nlet canv = null;\n\nlet startTick = -1;\nlet startTime = -1;\n\nshapeNames = ['triangle', 'square', 'circ', 'diamond', \"star\"]; \nfunction prtLine() {\n  logData.push(lines[0].path.map((x)=>{return shapeNames[x.type]}).join(\",\"));\n}\n\nlet basePopulationPool = 4;\nlet currPopulationPool = 3;\n\nlet totalScaleFac = 1;\nlet minSclFac = 0.5;\nconst maxSclFac = 3;\n\nlet hovering = null, hoveringConn = null;\nlet modifyingConn = null, modifyingTrain = null;\nlet hoveringTrain = null;\n\nlet stops = [];\nlet recentlyRemoved = [];\nlet connections = [];\nlet lineTypes = [];\nlet passengers = [];\nlet lines = [];\nlet lineCt = 0;\nlet trains = [];\nlet typesOnLine = [];\nlet passengersServed = 0;\n\nlet balance = 100000; // in thousands\nlet currCost_existing = 0;\nlet currCost = 0;\nlet balanceCap = 100000;\nlet overCost = false;\n\nlet extendInfo = null;\n\nlet asyncEvents = [];\n\nlet viewportW = 0;\nlet viewportH = 0;\nlet viewportMax, viewportMin;\n\nlet logData = [];\n\nlet currPath = [];\nlet downPt = null;\nlet currPos_canv = {x:0,y:0};\nlet currPos_abs = {x:0,y:0};\n\nlet trainsAvailable = 3;\nlet trainCost = 5000; // 5 million dollar train\nlet costPerPx = 10; // in k\nlet modifCost = 20000; // 20M base to modify\n// let extendCost = 500;\nlet costPerStation = 10000; // 50M a station\nlet yearlyBudget = 50000; // 10000k = 200m\n\nlet lineCost = 200000; // 200M!\n// let train\n\nlet maxUnlockedType = 0;\n\nconst acceptRadius = 30;\nconst stopSz = 17;\n\nlet nextMilestone = 20;\n\nlet adj = [];\n\n\n\nlet defaultClr = \"#555\";\nlet linesAvailable = 3;\nconst colours = [\"green\", \"yellow\", \"blue\", \"orange\", \"purple\", \"grey\"];\nlet DEBUG = true;\n\nlet prevYear = 1;\nlet globalTicks = 0;\nlet currSpeed = 1;\nlet offsetDelta = 0; // from saved time\n\nfunction onLoad() {\n\n}\n\nfunction purchaseLine() {\n  if (balance > lineCost) {\n    balance -= lineCost;\n    linesAvailable++;\n  }\n}\n\nfunction purchaseTrain() {\n  if (balance > trainCost) {\n    balance -= trainCost;\n    trainsAvailable++;\n  }\n}\n\n\nfunction timeNow() {\n  return globalTicks;\n}\n\nfunction ingametime() {\n  // 2s real-time, base ticks = 15 minutes in-game\n  // let sec = Math.floor(globalTicks/1000*(15/2)*60);\n  let mins = Math.floor(globalTicks/1000*(20/2));\n  let hrs = Math.floor(mins/60);\n  let days = Math.floor(mins*1.3);\n  return {m:mins%60, h:hrs%24, d:days%365, y:Math.floor(days/365)};\n}\n\nfunction togglePause() {\n  paused = !paused;\n  redraw();\n  if (!paused) {\n    requestAnimationFrame(tickLoop);\n  }\n}\n\nfunction getNextStop(currTrain, actQ=true) {\n  let line = lines[currTrain.lineID]\n  let currToIdx = line.path.indexOf(currTrain.to);\n  if (currTrain.revDir && currToIdx == 0)\n  {\n    if (line.loopingQ) {\n      nextStop = line.path[line.path.length-2];\n    }\n    else {\n      if (actQ) currTrain.revDir = !currTrain.revDir;\n      nextStop = line.path[1];\n    }\n  }\n  else if (!currTrain.revDir && currToIdx == line.path.length-1) {\n    // nextStop = currTrain.from;\n    nextStop = line.path[line.path.length-2];\n    if (actQ) currTrain.revDir = !currTrain.revDir;\n  }\n  else if (currTrain.revDir) {\n    nextStop = line.path[currToIdx-1];\n  }\n  else nextStop = line.path[currToIdx+1]; \n  if (!nextStop) debugger;\n  return nearestStop(nextStop, 1);\n}\n\nfunction handlePassenger(pass) {\n  if (pass.status != K.WAITING) return;\n  let minRouteLength = K.INF;\n  // let minRoute = [];\n  for (let l=0; l<pass.from.linesServed.size; l++) {\n    let lIdx = Array.from(pass.from.linesServed)[l];\n    for (let i=0; i<typesOnLine.length; i++) {\n      if (!typesOnLine[i].has(pass.to)) continue;\n      if (minRouteLength > adj[lIdx][i].val) {\n        minRouteLength = adj[lIdx][i].val;\n        // pass.route=adj[lIdx][i].route;\n        //WARNING! DO A DEEP COPY\n        pass.route = [];\n        for (let e of adj[lIdx][i].route)\n          pass.route.push(e);\n      }\n    }\n  }\n}\n\n\nfunction getAssociatedConnection(train) {\n  if (!train.to || !train.from) return null;\n  for (let cn of connections) {\n    if (samePt(cn.to, train.to) && samePt(cn.from, train.from) || \n        samePt(cn.from, train.to) && samePt(cn.to, train.from))\n      if (cn.lineID == train.lineID) return cn;\n  }\n  return null;\n}\n\nfunction populateStops() {\n  for (let n = 0; n<currPopulationPool; n++) {\n    let stopAdded = Math.floor(Math.random() * stops.length);\n    // if (stopAdded >= stops[i].type) stopAdded++;\n    let currType = getNextType(stops[stopAdded].type);\n    let pass = { from: stops[stopAdded], to: currType, route: [], \n                status: K.WAITING, actionStatus: K.NOACTION, train:null, stop:null};\n    passengers.push(pass);\n    handlePassenger(pass);\n    stops[stopAdded].waiting.push(pass);\n    let stop = stops[stopAdded]\n    if (stop.waiting.length > stop.capacity && !stop.failing) {\n      stop.failing = true;\n      stop.failureTimer=0;\n    }\n\n  }\n}\n\nfunction preLoad() {\n  vis(()=>{\n    if (vis()) document.title = \"thing\";\n    else {\n      paused = true;\n      openDialog(K.DIALOG_TIME);\n      document.title = \"thing (paused)\"\n    }\n  })\n  canv = byId(\"canv\");\n  ctx = canv.getContext(\"2d\");\n  prepSVG(\"passengersServed\", defaultClr);\n  registerMaximisingCanvas(\"canv\", 1, 0.95, redraw);\n  if ((docURL.searchParams.get(\"debug\")??\"yesplease\").match(/false|no|beans/)) {\n    DEBUG = false;\n  }\n  canv.addEventListener(\"pointermove\", onmove);\n  canv.addEventListener(\"pointerdown\",pointerdown);\n  window.addEventListener(\"keydown\", keyUpdate);\n  window.addEventListener(\"keyup\", keyUpdate);\n  window.addEventListener(\"pointerup\", (e)=>{routeConfirm(e); onmove(e)});\n  canv.addEventListener(\"wheel\", onWheel)\n  //////////\n  // setup stops\n  updateMinScl();\n  // let firstPoint = genRandomPt();\n  // firstPoint.waiting = [];\n  // stops.push(firstPoint);\n  // stops.type = 0;\n  // let canvMinDim = Math.min(viewportW, viewportH); \n  for (let i = 0; i < 3; i++) {\n    addNewStop(i);\n  }\n  totalScaleFac *= 0.8;\n  // translate(-viewportW/2, -viewportH/2);\n  scale(totalScaleFac);\n  translate(canv.width / 2, canv.height / 2);\n  redraw();\n  //////\n  // setInterval(tickLoop, 1000/60);\n  requestAnimationFrame(tickLoop);\n  HTMLActions();\n  requestAnimationFrame(animLoop);\n  startTick = timeNow();\n  startTime = Date.now();\n  asyncEvents.push({fcn:stopPopulationLoop, time:timeNow()+10000});\n}\n\nfunction animLoop() {\n  if (currSpeed < 0.05) alertDialog(\"You lost!\", ()=>{});\n  let delta = Date.now() - startTime;\n  startTime = Date.now();\n  \n  redraw(delta);\n  requestAnimationFrame(animLoop);\n}\n\n\n\nfunction tickLoop() {\n  globalTicks += 16.66667*currSpeed; // 60fps default\n  let igt = ingametime();\n  if (igt.y > prevYear) {\n    balance += yearlyBudget;\n    balance = Math.min(balanceCap, balance);\n    prevYear = igt.y;\n  }\n  if (igt.h < 6 || igt.h > 22) \n    currPopulationPool = basePopulationPool*0.5;\n  else if (igt.h >= 6 && igt.h<=8\n     || igt.h >= 17 && igt.h <= 19) currPopulationPool = basePopulationPool*1.5;\n  else currPopulationPool = basePopulationPool;\n  for (let i=0; i<asyncEvents.length; i++) {\n    if (timeNow() >= asyncEvents[i].time) {\n      asyncEvents[i].fcn();\n      asyncEvents.splice(i, 1);\n      i--;\n    } \n  }\n  for (let i = 0; i < trains.length; i++) {\n    if (trains[i].pendingMove) continue;\n    if (trains[i].pendingRemove && trains[i].passengers.length == 0) {\n      trains.splice(i, 1);\n      i--;\n      continue;\n    }\n    let currTrain = trains[i];\n    let distTotal = distBtw(trains[i].to, trains[i].from);\n    // distToCover = s * px/s / px\n    let distTravelled = (timeNow() - currTrain.startT) * trainSpeed;\n    let percentCovered = distTravelled / distTotal;\n    trains[i].percentCovered = percentCovered;\n    if (percentCovered < 0) continue;\n    if (percentCovered >= 1) { // at a stop. \n      let startT = timeNow();\n      percentCovered = 0;\n      // let applicable = [];\n      let currentTo = trains[i].to;//trains[i].revDir?trains[i].from:trains[i].to;\n      let currStop = nearestStop(currentTo, 1);\n      // currTrain.onCompletion = currTrain.passengers.length;\n      // how many people to drop off here?\n      let delay = dropOff(currTrain, currentTo) * K.DELAYPERPASSENGER;\n      // figure out if the train is due to reverse first.\n      let reverseQ = true;\n      let nextStop = null;\n      // for (let j = 0; j < connections.length && reverseQ; j++) {\n      //   if ((trains[i].revDir ? samePt(connections[j].to, currentTo)\n      //     : samePt(connections[j].from, currentTo))\n      //     && connections[j].lineID == trains[i].lineID) {\n      //     reverseQ = false;\n      //     nextStop = trains[i].revDir ? connections[j].from : connections[j].to;\n      //   }\n      // }\n      // no need to do all this nonsense the train knows its path\n      let prevStop = currTrain.from;\n      nextStop = getNextStop(currTrain);\n      // if next stop is the same as the prev stop - we know that the train is reversing\n\n\n      // who to pick up?\n      //  find which stops this line supports\n      // let availableTransfers = new Set();\n\n      // while (true) {\n      currStop = nearestStop(currentTo, 1);\n      let upcomingLinesServed = new Set(JSON.parse(JSON.stringify([...currStop.linesServed])));\n      // 1. drop off people who are transferring - MAKE SURE THEY'RE ON THEIR WAY!\n      for (let j=0; j<currTrain.passengers.length; j++) {\n        let pass = currTrain.passengers[j];\n        if (pass.route.length > 0 && pass.status == K.ONTHEWAY \n            && pass.actionStatus == K.NOACTION &&\n            upcomingLinesServed.has(pass.route[0])) {\n          // currTrain.passengers.splice(j, 1);\n          // currStop.toAdd.push({from:currTrain,pass:pass});\n          // currTrain.onCompletion--;\n          // // currStop.waiting.push(pass);\n          // // debugger;\n          // // j--;\n          pass.actionStatus = K.TRANSFERPENDING;\n          // pass.status = K.WAITING;\n          pass.stop = currStop;\n          pass.train = currTrain;\n          pass.route.shift();\n          delay += K.DELAYPERPASSENGER;\n        }\n      }\n      // 2. pick up people who need transfers (they typically wait very long)\n      for (let j=0; j<connections.length; j++) {\n        if (connections[j].lineID == currTrain.lineID) {\n          let fStop = nearestStop(connections[j].from, 1);\n          let tStop = nearestStop(connections[j].to, 1);\n          for (const nextLine of fStop.linesServed) \n            upcomingLinesServed.add(nextLine);\n          for (const nextLine of tStop.linesServed) \n            upcomingLinesServed.add(nextLine);\n        }\n      }\n      for (let j=0; j<currStop.waiting.length; j++) {\n        let pass = currStop.waiting[j];\n        // if (currTrain.onCompletion >= currTrain.cap) break;\n        if (currStop.waiting[j].actionStatus != K.NOACTION) continue;\n        if (pass.route.length > 0 && upcomingLinesServed.has(pass.route[0])) {\n          // currStop.waiting.splice(j, 1);\n          currStop.waiting[j].actionStatus = K.BOARDPENDING;\n          // pass.status = K.ONTHEWAY;\n          currStop.waiting[j].stop = currStop;\n          currStop.waiting[j].train = currTrain;\n          // j--;\n          // currTrain.onCompletion++;\n          // currTrain.toAdd.push({stop:currStop,pass:pass});\n          // pass.status = K.ONTHEWAY;\n          delay += K.DELAYPERPASSENGER;\n        }\n      }\n\n      // 3. pick up people who do not have transfers at all\n      for (let k = 0; k < currStop.waiting.length; k++) {\n        // if (currTrain.passengers.length >= currTrain.cap) break;\n        // for (let j = 0; j < typesOnLine.length; j++) {\n\n        if (currStop.waiting[k].actionStatus != K.NOACTION) continue;\n        if (typesOnLine[currTrain.lineID].has(currStop.waiting[k].to)) {\n          let adding = currStop.waiting[k];\n          currStop.waiting[k].actionStatus = K.BOARDPENDING;\n          currStop.waiting[k].stop = currStop;\n          currStop.waiting[k].train = currTrain;\n          // adding.status = K.ONTHEWAY;\n          // currStop.waiting.splice(k, 1);\n          // currTrain.toAdd.push({stop:currStop,pass:adding});\n          // k--;\n        }\n        delay += K.DELAYPERPASSENGER;\n        // }\n      }\n      // if (currTrain.revDir) {\n      if (delay > 0) currTrain.startT = K.INF;\n      let connBeforeUpdate = getAssociatedConnection(currTrain);\n      // if (!connBeforeUpdate.pendingRemove) connBeforeUpdate = null;\n      currTrain.from = currTrain.to;\n      currTrain.to = nextStop;\n\n      handleAwaiting(currTrain, currStop);\n\n\n      // }\n      if (timeNow() - startT > 25) \n        console.log(\"WARNING: StopHandler took \", timeNow() - startT+\"ms\");\n    } // if percentcoered = 1\n    currTrain.x = currTrain.from.x + (currTrain.to.x - currTrain.from.x) * percentCovered;\n    currTrain.y = currTrain.from.y + (currTrain.to.y - currTrain.from.y) * percentCovered;\n  }\n  for (let i=0; i<stops.length; i++) {\n    if (stops[i].failurePct < 0) continue;\n    let pctRemaining = stops[i].failurePct;\n    if (pctRemaining > 1) {\n      currSpeed*=0.99;\n      // alertDialog(\"loser!\", ()=>{\n      //   location.reload();\n      // });\n      // return;\n    }\n  }\n  let delta = timeNow() - startTick;\n  startTick = timeNow();\n  for (let stop of stops) {\n    if (stop.failing) stop.failurePct+=K.PCTPERTICK*delta;\n    else stop.failurePct= Math.max(0, stop.failurePct-K.PCTPERTICK*delta)\n  }\n  for (let train of trains) {\n    if (train.pendingMove && train.passengers.length == 0 && !train.moving) {\n      train.pendingMove = false;\n      train.startTime = timeNow();\n    }\n  }\n  // redraw(delta);\n  if (!paused) requestAnimationFrame(tickLoop);\n}\n\nfunction handleAwaiting(currTrain, currStop) {\n  let handled = false;\n  for (const pass of passengers) {\n    if (pass.train != currTrain || pass.stop != currStop) continue;\n    else if (pass.actionStatus == K.NOACTION) {\n      continue;\n    }\n    // if people are trying to get on the train but unable to do so - abandon the action and wait for next recalculation\n    else if (currTrain.passengers.length >= currTrain.cap && \n             pass.actionStatus == K.BOARDPENDING) {\n      pass.actionStatus = K.NOACTION;\n      continue;\n    }\n    else if (pass.actionStatus == K.BOARDPENDING) {\n      pass.actionStatus = K.NOACTION;\n      for (let i=0; i<currStop.waiting.length; i++) \n        if (currStop.waiting[i] == pass) {\n          currStop.waiting.splice(i, 1);\n          currTrain.passengers.push(pass);\n          break;\n        }\n      if (currStop.waiting.length < currStop.capacity) {\n        currStop.failing = false;\n      }\n      pass.status = K.ONTHEWAY;\n      pass.actionStatus = K.NOACTION;\n      handled = true;\n      break;\n    }\n    else if (pass.actionStatus == K.DEBOARDPENDING) {\n      pass.actionStatus = K.NOACTION;\n      for (let i=0; i<currTrain.passengers.length; i++) \n        if (currTrain.passengers[i] == pass) {\n          currTrain.passengers.splice(i,1);\n          break;\n        }\n      pass.status = K.WAITING;\n      if (currStop.waiting.length < currStop.capacity)\n        currStop.failing =false;\n      pass.actionStatus = K.NOACTION;\n      passengersServed+= 1;\n      handled = true;\n      break;\n    }\n    else if (pass.actionStatus == K.TRANSFERPENDING) {\n      pass.actionStatus = K.NOACTION;\n      for (let i=0; i<currTrain.passengers.length; i++) \n        if (currTrain.passengers[i] == pass) {\n          currTrain.passengers.splice(i,1);\n          currStop.waiting.push(pass);\n          break;\n        }\n      pass.status = K.WAITING;\n      pass.actionStatus = K.NOACTION;\n      let stop = currStop;\n      if (stop.waiting.length > stop.capacity && stop.failurePct < 1)\n        stop.failing=true;\n      handled = true;\n      break;\n    }\n       // train gone, need to catch the next train\n    else if (pass.actionStatus == K.REBOARDREQUIRED) {\n      console.log(\"handling\");\n      pass.route.splice(0, 0, currTrain.lineID);\n      // let stop = currTrain.dropOffLocation;\n      for (let i=0; i<currTrain.passengers.length; i++) \n      if (currTrain.passengers[i] == pass) {\n        currTrain.passengers.splice(i,1);\n        currStop.waiting.push(pass);\n        break;\n      }\n      pass.status = K.WAITING;\n      pass.actionStatus = K.NOACTION;\n      let stop = currStop;\n      if (stop.waiting.length > stop.capacity && stop.failurePct < 1)\n        stop.failing=true;\n      handled = true;\n      break;\n    }\n    else throw(\"invalid actionStatus!\");\n  }\n  if (handled) {\n\n    let toCall = {fcn:()=>{handleAwaiting(currTrain, currStop)}, time:timeNow()+K.DELAYPERPASSENGER};\n    asyncEvents.push(toCall);\n  }\n  else {\n    currTrain.startT = timeNow();\n    for (const affectedConn of connections) {\n      if (affectedConn.pendingRemove) {\n        let canUpdate = true;\n        // check if all trains have cleared this connection\n        let currLine = lines[affectedConn.lineID];\n        for (affectedTrain of currLine.trains) {\n          if (getAssociatedConnection(affectedTrain) == affectedConn) {\n            canUpdate = false;\n            break;\n          }\n        }\n        if (canUpdate) updateToNow(currLine, affectedConn);\n      }\n    }\n\n  }\n  if (passengersServed > nextMilestone) {\n    nextMilestone*=1.3;\n    addNewStop();\n    basePopulationPool *= 1.1;\n  }\n}\n\nfunction dropOff(currTrain, pt) {\n  let stop = nearestStop(pt, 1);\n  let matching = 0;\n  for (let i = 0; i < currTrain.passengers.length; i++)\n    if (currTrain.passengers[i].to == stop.type && currTrain.passengers[i].actionStatus == K.NOACTION) {\n      matching++;\n      // currTrain.passengers.splice(i, 1);\n      // currTrain.onCompletion--;\n      currTrain.passengers[i].actionStatus = K.DEBOARDPENDING;\n      currTrain.passengers[i].stop = stop;\n      currTrain.passengers[i].train = currTrain;\n      // currTrain.toRemove.push({stop:stop, pass:currTrain.passengers[i]});\n      // i--;\n    }\n  return matching;\n}\n\nfunction stopPopulationLoop() {\n  populateStops();\n  redraw();\n  asyncEvents.push({fcn:stopPopulationLoop, time:timeNow()+(5000 + Math.random() * 7000)});\n}\n\n\n\nfunction addNewStop(type = -1) {\n  let newPt;\n  if (type < 0) type = getNextType();\n  if (stops.length > 0)\n    do {\n      // newPt = genRandomPt();\n      // this is stupid.\n      refPt = stops[Math.floor(Math.random() * stops.length)];\n      // if (refPt)\n      ang = Math.random() * 2 * K.PI;\n      dist = 150 + Math.random() * 100\n      newPt = { x: refPt.x + dist * Math.cos(ang), y: refPt.y + dist * Math.sin(ang) };\n    } while (!(!nearestStop(newPt, 150) && withinViewport(newPt)));\n  else newPt = genRandomPt();\n  stops.push(newPt);\n  maxUnlockedType = Math.max(maxUnlockedType, type);\n  updateMinScl(minSclFac * 0.98);\n  newPt.waiting = [];\n  newPt.linesServed = new Set();\n  newPt.type = type;\n  newPt.addedTime = Date.now();\n  newPt.toAdd = [];\n  newPt.stopID = stops.length;\n  newPt.failing = false;\n  newPt.failurePct = 0;\n  newPt.capacity = 10;\n  redraw();\n}\n\nfunction keyUpdate(ev) {\n}\n\n\n\nfunction terminals(stop) {\n  let out = [];\n  for (let i=0; i<lines.length; i++)\n    if ((lines[i].path[0] == stop || lines[i].path[lines[i].path.length-1] == stop)\n      && lines[i].path[0] != lines[i].path[lines[i].path.length-1])\n      out.push(lines[i]);\n  return out.length == 0?null:out;\n}\n\nfunction updateToNow(currLine, conn) {\n  // for (affectedTrain of currLine.trains) {\n  // let fIdx = affectedTrain.path.indexOf(conn.from);\n    // affectedTrain.path.splice(fIdx+1, 0, nStop);\n  // }\n  // conn.to = nStop; \n  let idx = connections.indexOf(conn);\n  connections.splice(idx, 1);\n  recentlyRemoved.push({conn:conn, time:timeNow()});\n  // connections.push(newConn);\n}\n\n\nfunction samePt(pt1, pt2) {\n  return Math.abs(pt1.x - pt2.x) < 0.1 && Math.abs(pt1.y - pt2.y) < 0.1;\n}\n\nfunction genRandomPt() {\n  return {\n    x: Math.random() * viewportW - viewportW / 2,\n    y: Math.random() * viewportH - viewportH / 2\n  }\n}\n\nfunction nearestStop(newPt, minDist) {\n  let found = null;\n  for (let i = 0; i < stops.length; i++) {\n    let dist = distBtw(stops[i], newPt);\n    if (dist < minDist) {\n      found = stops[i];\n      minDist = dist;\n    }\n  }\n  return found;\n}\n\nfunction distBtw(pt1, pt2) {\n  function sq(x) { return x * x; }\n  return Math.sqrt(sq(pt1.x - pt2.x) + sq(pt1.y - pt2.y));\n}\n\n\nfunction getNextType(exclude = -1) {\n  let type = Math.floor(Math.random() * (exclude < 0 ? Math.min(maxUnlockedType+2, types.length) : maxUnlockedType));\n  if (type >= exclude && exclude >= 0) return type + 1;\n  return type;\n  // if ()\n}\n\nfunction recalculateLineConnections() {\n  adj = [];\n  for (let i = 0; i < typesOnLine.length; i++) {\n    let row = [];\n    for (let j = 0; j < typesOnLine.length; j++) {\n      row.push({ route:[], val: K.INF });\n    }\n    adj.push(row);\n  }\n  for (let i = 0; i < stops.length; i++) {\n    let served = Array.from(stops[i].linesServed);\n    for (let j = 0; j < served.length; j++) {\n      for (let k = 0; k < served.length; k++) {\n        adj[served[j]][served[k]].val = 1;\n        adj[served[j]][served[k]].route = [served[k]];\n        adj[served[k]][served[j]].val = 1;\n        adj[served[k]][served[j]].route = [served[j]];\n      }\n    }\n    for (let j=0; j<served.length; j++) {\n      adj[served[j]][served[j]].val = 0;\n      adj[served[j]][served[j]].route = [];\n    }\n  }\n  for (let k = 0; k < adj.length; k++) {\n    for (let j = 0; j < adj.length; j++) {\n      for (let i = 0; i < adj.length; i++) {\n        if (i == k || j == k) continue;\n        let newCost = adj[i][k].val+adj[k][j].val;\n        if (newCost < adj[i][j].val) {\n          adj[i][j].val = newCost;\n          adj[i][j].route = [];\n\n          // let replaceIdx = adj[i][j].indexOf(i);\n          for (let n=0; n<adj[i][k].route.length; n++) \n            adj[i][j].route.push(adj[i][k].route[n])\n          for (let n=0; n<adj[k][j].route.length; n++) \n            adj[i][j].route.push(adj[k][j].route[n])\n        }\n        // adj[i][j].val = Math.min(adj[i][j].val, adj[i][k].val + adj[k][j].val);\n      }\n    }\n\n  }\n  console.log(\"==== RECALCULATION SUCCESS ====\")\n}"],
  "mappings": "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",
  "names": ["nextStop", "dist"]
}
