{
  "version": 3,
  "sources": ["../../frontend/game.js"],
  "sourcesContent": ["const K = {\n  MOVING:1,\n  STOPPED:2,\n  NOHOLD:0,\n  HOLD:1,\n  HOLD_NEWLINE:2\n}\nconst trainSpeed = 50/1000; // pixels/ms\nlet holdState = K.NOHOLD;\nlet ctx = null;\nlet canv = null;\nlet totalScaleFac = 1;\nlet stops = [];\nlet connections = [];\nlet stopCt = 0;\nlet minSclFac = 0.5;\nconst maxSclFac = 3;\nlet viewportW = 0;\nlet viewportH = 0;\nlet viewportMax, viewportMin;\nlet currPath = [];\nlet trains = [];\nconst acceptRadius = 30;\nconst stopSz = 5;\nlet currPos_canv = null;\nlet lineCt = 0;\nlet shiftStatus = false;\nlet downPt = null;\nlet types = [triangle, square, circ, star];\nlet defaultClr = \"#000\";\nconst colours = [\"green\", \"yellow\", \"blue\", \"orange\", \"purple\", \"grey\"]\nfunction onLoad() {\n  \n}\n\nfunction redraw() {\n  // function connect(currPath, clr) {\n  function circle(pt) {\n    ctx.save();\n      clearCircle(pt, acceptRadius);\n      ctx.beginPath();\n      ctx.arc(pt.x, pt.y, stopSz, 0, Math.PI*2);\n      ctx.stroke();\n      // ctx.strokeStyle;\n      ctx.beginPath();\n      ctx.arc(pt.x, pt.y, acceptRadius, 0, Math.PI*2);\n      ctx.stroke();\n    ctx.restore();\n    ctx.beginPath();\n  }\n  function clearCircle(pt, rad) {\n    ctx.beginPath();\n    ctx.fillStyle = getCSSProp(\"--system-grey3\");\n    ctx.save();\n      ctx.arc(pt.x, pt.y, rad+2, 0, Math.PI*2);\n      ctx.clip();\n      ctx.save();\n        ctx.resetTransform();\n        ctx.clearRect(0, 0, canv.width, canv.height);\n      ctx.restore();\n      ctx.fill();\n    ctx.restore();\n    ctx.beginPath();\n  }\n  updateMinScl();\n  ctx.beginPath();\n  ctx.save();\n    ctx.resetTransform();\n    ctx.fillStyle = getCSSProp(\"--system-grey3\");\n    ctx.clearRect(0, 0, canv.width, canv.height);\n    ctx.fillRect(0, 0, canv.width, canv.height);\n  ctx.restore();\n  ctx.beginPath();\n  ctx.lineWidth = 3;\n  ctx.moveTo(0, 0);\n  ctx.lineTo(canv.width, canv.height);\n  ctx.stroke();\n  ctx.beginPath();\n\n  ////////// little stop circles //////////\n  for (let i=0; i<stops.length; i++) {\n    ctx.arc(stops[i].x, stops[i].y, stopSz, 0, Math.PI*2);    \n    ctx.stroke();\n    ctx.beginPath();\n    ctx.fillStyle = defaultClr;\n    let out = \" \";\n    for (let j=0; j<stops[i].waiting.length; j++) {\n      out += stops[i].waiting[j].toString();\n    }\n    ctx.fillText(out, stops[i].x+stopSz, stops[i].y-stopSz/2);\n  }\n  // existing paths///////////\n  for (let i=0; i<connections.length; i++) {\n    // if (lines.length > 0) ctx.arc(lines[i][0].x, lines[i][0].y, acceptRadius, 0, Math.PI*2);\n    // // for (let i=1; i<currPath.length; i++) {\n    let angBtw = Math.atan2(connections[i].to.y-connections[i].from.y, \n                            connections[i].to.x-connections[i].from.x);\n    // angBtw += Math.PI;\n    ctx.save();\n      ctx.beginPath();\n      let c = Math.cos(angBtw);\n      let s = Math.sin(angBtw);\n      ctx.strokeStyle = connections[i].colour;\n      ctx.moveTo(connections[i].from.x + c*stopSz, \n                 connections[i].from.y + s*stopSz);\n      ctx.lineTo(connections[i].to.x - c*stopSz, \n                 connections[i].to.y - s*stopSz)\n      ctx.stroke();\n    ctx.restore();\n  }\n  \n  ctx.save();\n  ctx.lineWidth = 4;\n  //////// current path /////////\n  // connect(currPath, getCSSProp(\"--system-green\"));\n  ctx.save();\n    ctx.beginPath();\n    ctx.strokeStyle = defaultClr;\n    ctx.stroke();\n    for (let i=1; i<currPath.length; i++) {\n      let angBtw = Math.atan2(currPath[i].y-currPath[i-1].y, \n                              currPath[i].x-currPath[i-1].x);\n      ctx.beginPath();\n      let c = Math.cos(angBtw);\n      let s = Math.sin(angBtw);\n      ctx.strokeStyle = getCSSProp(\"--system-\"+colours[0]);\n      ctx.moveTo(currPath[i-1].x + c*acceptRadius, currPath[i-1].y + s*acceptRadius);\n      ctx.lineTo(currPath[i].x -   c*acceptRadius, currPath[i].y   - s*acceptRadius)\n      ctx.stroke();\n      ctx.strokeStyle = defaultClr;\n    }\n  ctx.beginPath();\n\n\n  //////////////// then put the current path large circles /////////\n  for (let i=0; i<currPath.length; i++) {\n    ctx.save();\n      ctx.strokeStyle = getCSSProp(\"--system-\"+colours[0]);\n      circle(currPath[i]);\n    ctx.restore();\n  }\n\n  //////////////// existing path lines ////////////////////\n  for (let i=0; i<connections.length; i++) {\n    // ctx.strokeStyle = getCSSProp(\"--\")\n    clearCircle(connections[i].from, stopSz);\n    clearCircle(connections[i].to, stopSz);\n    ctx.beginPath();\n    ctx.strokeStyle = defaultClr;\n    ctx.arc(connections[i].from.x, connections[i].from.y, stopSz, 0, Math.PI*2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(connections[i].to.x, connections[i].to.y, stopSz, 0, Math.PI*2);\n    ctx.stroke();\n    // circle(connections[i].from)//, connections[i].colour);\n    // circle(connections[i].to) //, connections[i].colour);\n  }\n  ctx.restore();\n  ctx.beginPath();\n  ////////////////////////////////\n  ctx.restore();\n  ctx.beginPath();\n  if (holdState == K.HOLD_NEWLINE) {\n    // must have a starting poibt\n    let lastPt = currPath[currPath.length-1];\n    let angBtw = Math.atan2(currPos_canv.y - lastPt.y,\n                            currPos_canv.x - lastPt.x);\n    let c = Math.cos(angBtw);\n    let s = Math.sin(angBtw);\n    let nextStop = nearestStop(currPos_canv, acceptRadius);\n    if (nextStop && samePt(nextStop, lastPt)) { // accepted new stop\n      clearCircle(lastPt, acceptRadius);\n      ctx.save();\n      ctx.beginPath();\n      ctx.lineWidth = 4;\n      ctx.strokeStyle = getCSSProp(\"--system-\"+colours[0]);\n      ctx.arc(lastPt.x, lastPt.y, stopSz, 0, Math.PI*2);\n      ctx.stroke();\n      circle(lastPt);\n      ctx.restore();\n      \n    }\n    ctx.beginPath();\n    // else if (!nextStop) {\n    if (nextStop && samePt(nextStop, lastPt)); // return;\n    // THERE'S A PROBLEM.\n    else if (nextStop) {\n      \n      angBtw = Math.atan2(nextStop.y - lastPt.y,\n                          nextStop.x - lastPt.x);\n      c = Math.cos(angBtw);\n      s = Math.sin(angBtw);\n      ctx.moveTo(lastPt.x + c*acceptRadius, lastPt.y + s*acceptRadius);\n      \n      ctx.save();\n      ctx.strokeStyle = getCSSProp(\"--system-\"+colours[0]);\n      ctx.lineTo(nextStop.x - c*acceptRadius, nextStop.y - s*acceptRadius);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = getCSSProp(\"--system-red\");\n      ctx.arc(nextStop.x, nextStop.y, stopSz, 0, Math.PI*2);\n      ctx.stroke();\n      circle(nextStop);\n      ctx.restore();\n    }\n    // just not connected yet.\n    else {\n      ctx.moveTo(lastPt.x + c*acceptRadius, lastPt.y + s*acceptRadius);\n      ctx.save();\n      ctx.lineWidth = 4;\n      ctx.strokeStyle = getCSSProp(\"--system-\"+colours[0]);\n      ctx.lineTo(currPos_canv.x, currPos_canv.y);\n      ctx.stroke();\n      ctx.restore();\n    }\n    // if (!samePt(nextStop, lastPt)) \n    //   ctx.strokeStyle = getCSSProp(\"--system-red\");\n    // else \n      // ctx.strokeStyle = getCSSProp(\"--system-green\");\n    \n    // }\n  }\n  // now we draw the trains!\n  for (let i=0; i<trains.length; i++) {\n    ctx.beginPath();\n    let angBtw = Math.atan2(trains[i].to.y-trains[i].from.y,\n                            trains[i].to.x-trains[i].from.x);\n    let center = {x:trains[i].x, y:trains[i].y};\n    // console.log(center);\n    ctx.save();\n      // ctx.translate(-center.x, -center.y)\n      // ctx.rotate(angBtw);\n      // ctx.translate(center.x, center.y);\n      ctx.fillStyle = getCSSProp(\"--system-grey\");\n      ctx.fillRect(center.x - 8, center.y-2.5, 16, 5);\n    ctx.restore();\n  }\n}\n\nfunction registerMaximisingCanvas(id, widthPc, heightPc, redrawFcn) { // (id:string, widthPc:number, heightPc:number, redrawFcn:()=>any) {\n  //let canv = byId(id)// as HTMLCanvasElement;\n  window.addEventListener(\"resize\", (ev)=>{\n    console.log(\"resizing\");\n    canv.width = window.innerWidth*widthPc;\n    canv.height = window.innerHeight*heightPc;\n    // everything is gone - restore it!\n    applyTransfm();\n    redrawFcn();\n  })\n  canv.style.height = 100*heightPc+\"vh\";\n  canv.style.width = 100*widthPc+\"vw\";\n  canv.width = window.innerWidth*widthPc;\n  canv.height = window.innerHeight*heightPc;\n  redrawFcn();\n}\n\nfunction populateStops() {\n  for (let i=0; i<stops.length; i++) {\n    if (Math.random() < 0.4) continue;\n    let toAdd = Math.floor(Math.random()*(stops.length)/3)+1;\n    for (let j=0; j<toAdd; j++) {\n      let stopAdded = Math.floor(Math.random()*stops.length);\n      stops[stopAdded].waiting.push(getNextType());\n    }\n  }\n}\n\nfunction preLoad() {\n  canv = byId(\"canv\");\n  ctx = canv.getContext(\"2d\");\n  registerMaximisingCanvas(\"canv\", 1, 0.95, redraw);\n  canv.addEventListener(\"pointermove\", onmove);\n  canv.addEventListener(\"pointerdown\", (ev)=>{\n    holdState = K.HOLD;\n    downPt = {x:ev.clientX, y:ev.clientY};\n    if (ev.shiftKey) {\n      document.body.style.cursor = \"grabbing\";\n    }\n    let actualPos = fromCanvPos(ev.clientX, ev.clientY);\n    let nStop = nearestStop(actualPos, acceptRadius);\n    if (nStop && colours.length>0) {\n      holdState = K.HOLD_NEWLINE;\n      console.log(nStop);\n      currPath = [nStop];\n      redraw();\n    }\n    console.log(\"holdState\", holdState)\n  });\n  window.addEventListener(\"keydown\", keyUpdate);\n  window.addEventListener(\"keyup\", keyUpdate);\n  window.addEventListener(\"pointerup\", pointerUp);\n  canv.addEventListener(\"wheel\", (ev)=>{\n    // larger -ve deltaY: \n    // ctx.\n    let sclFac = (ev.deltaY<0?Math.pow(10, -ev.deltaY/750):Math.pow(10, -ev.deltaY/400))\n    if (sclFac*totalScaleFac > maxSclFac)\n      sclFac = maxSclFac/totalScaleFac;\n    if (sclFac*totalScaleFac < minSclFac) \n      sclFac = minSclFac/totalScaleFac;\n    // console.log(sclFac, totalScaleFac);\n    translate(-ev.clientX, -ev.clientY);\n    scale(sclFac);\n    translate(ev.clientX, ev.clientY);\n    totalScaleFac *= sclFac;\n    redraw();\n  })\n  //////////\n  // setup stops\n  updateMinScl();\n  let firstPoint = genRandomPt();\n  firstPoint.waiting = [];\n  stops.push(firstPoint);\n  stops.type = 0;\n  // let canvMinDim = Math.min(viewportW, viewportH); \n  for (let i=0; i<2; i++) {\n    addNewStop(i+1);\n  }\n  totalScaleFac*= 0.8;\n  console.log(viewportW, viewportH);\n  // translate(-viewportW/2, -viewportH/2);\n  redraw();\n  scale(totalScaleFac);\n  redraw();\n  translate(canv.width/2, canv.height/2);\n  redraw();\n  //////\n  setInterval(animLoop, 1000/60);\n  setTimeout(stopPopulationLoop, 5000);\n}\n\nfunction animLoop() {\n  for (let i=0; i<trains.length; i++) {\n    let currTrain = trains[i];\n    let distTotal = distBtw(trains[i].to, trains[i].from);\n    // distToCover = s * px/s / px\n    let distTravelled = (Date.now() - currTrain.startT)*trainSpeed;\n    // console.log(distTravelled);\n    let percentCovered = distTravelled/distTotal;\n    if (percentCovered < 0) continue;\n    if (percentCovered >= 1) {\n      percentCovered = 0;\n      let delay = numberMatching(currTrain, trains[i].to)\n      \n    }\n    currTrain.x = currTrain.from.x + (currTrain.to.x - currTrain.from.x)*percentCovered;\n    currTrain.y = currTrain.from.y + (currTrain.to.y - currTrain.from.y)*percentCovered;\n    redraw();\n    // console.log(currTrain.x, currTrain.y, percentCovered)\n  }\n  redraw();\n}\n\nfunction numberMatching(currTrain, pt) {\n  let stop = nearestStop(pt, 1);\n  let matching = 0;\n  for (let i=0; i<currTrain.passengers.length; i++) \n    if (currTrain.passengers[i] == stop.type) matching++;\n  return matching;\n}\n\nfunction stopPopulationLoop() {\n  populateStops();\n  redraw();\n  setTimeout(stopPopulationLoop, 5000+Math.random()*7000);\n}\n\nfunction updateMinScl(newVal=minSclFac) {\n  minSclFac = newVal;\n  viewportW = canv.width/minSclFac*0.2;\n  viewportH = canv.height/minSclFac*0.2;\n  viewportMax = Math.max(viewportW, viewportH);\n  viewportMin = Math.min(viewportW, viewportH);\n}\n\nfunction addNewStop(type=-1) {\n  let newPt;\n  if (type < 0) type = getNextType();\n  do {\n    // newPt = genRandomPt();\n    // this is stupid.\n    refPt = stops[Math.floor(Math.random()*stops.length)];\n    ang = Math.random()*2*Math.PI;\n    dist = 150+Math.random()*100\n    newPt = {x:refPt.x+dist*Math.cos(ang), y:refPt.y+dist*Math.sin(ang)};\n  } while (nearestStop(newPt, 150) ||\n          withinViewport(newPt));\n  stops.push(newPt);\n  updateMinScl(minSclFac * 0.99);\n  newPt.waiting = [];\n  newPt.type = type;\n  redraw();\n}\n\nfunction keyUpdate(ev) {\n  if (!shiftStatus && ev.shiftKey)\n    document.body.style.cursor = \"grab\";\n  else if (shiftStatus && !ev.shiftKey) \n    document.body.style.cursor = \"\";\n  shiftStatus = ev.shiftKey;\n}\n\nfunction onmove(ev) {\n  // if (ev.shiftKey) {\n  //   document.body.style.cursor = \"grabbing\";\n  // }\n  currPos_canv = fromCanvPos(ev.clientX, ev.clientY);\n  if (holdState != K.NOHOLD && ev.shiftKey) {\n    translate(ev.movementX, ev.movementY);\n    redraw();\n  }\n  else if (holdState == K.HOLD_NEWLINE) {\n    let actualPos = fromCanvPos(ev.clientX, ev.clientY);\n    let nStop = nearestStop(actualPos, acceptRadius);\n    let lastStop = currPath[currPath.length-1];\n    // if (!nStop) // \n    //   currPath.pop();\n    // else console.log(nStop);\n    if (nStop) {\n      let canAdd = true;\n      for (let i=0; i<currPath.length && canAdd; i++) {\n        if (samePt(currPath[i], nStop)) canAdd =  false;\n      }\n      if (!canAdd && currPath.length > 2 \n          && samePt(nStop, currPath[0]) && !samePt(nStop, lastStop)) {\n        canAdd = true;\n        holdState = K.NOHOLD;\n      }\n      if (canAdd) {\n        currPath.push(nStop);\n        console.log(nStop);\n      }\n    }\n    redraw();\n  }\n}\n\nfunction pointerUp(ev) {\n  holdState = K.NOHOLD;\n  document.body.style.cursor = shiftStatus?\"grab\":\"\";\n  if (currPath.length > 1) {\n    let currCol = getCSSProp(\"--system-\"+colours[0]);\n    colours.shift();\n    // lines.push({path:currPath, \n                // colour:getCSSProp(\"--system-\"+colours[lines.length])});\n    for (let i=1; i<currPath.length; i++) {\n      connections.push({from:currPath[i-1], to:currPath[i], \n                        colour:currCol, lineID: lineCt});\n    }\n    trains.push({x:currPath[0].x, y:currPath[0].y, \n                 from:currPath[0], to:currPath[1], path:currPath, \n                 lineID: lineCt, colour:currCol, startT: Date.now(), \n                  status:K.MOVING, passengers:[]});\n    lineCt++;\n  }\n  currPath = [];\n  redraw();\n  if (!downPt || distBtw({x:ev.clientX, y:ev.clientY}, downPt) > 10) return;\n  // check for is it actually a click ^\n  ctx.beginPath();\n  let actualPos = fromCanvPos(ev.clientX, ev.clientY);\n  ctx.moveTo(actualPos.x-0.5, actualPos.y-0.5);\n  ctx.lineTo(actualPos.x+0.5, actualPos.y+0.5);\n  ctx.stroke();\n  ctx.fillText(actualPos.x.toFixed(2)+\", \"+actualPos.y.toFixed(2), actualPos.x, actualPos.y);\n}\n\nfunction samePt(pt1, pt2) {\n  return Math.abs(pt1.x-pt2.x) < 0.1 && Math.abs(pt1.y-pt2.y) < 0.1;  \n}\n\nfunction genRandomPt() {\n  return {x:Math.random()*viewportW - viewportW/2, \n    y:Math.random()*viewportH - viewportH/2}\n}\n\nfunction nearestStop(newPt, minDist) {\n  let found = null;\n  for (let i=0; i<stops.length; i++) {\n    let dist = distBtw(stops[i], newPt);\n    if (dist < minDist) {\n      found = stops[i];\n      minDist = dist;\n    }\n  }\n  return found;\n}\n\nfunction withinViewport(newPt) {\n  // let viewportScl = minSclFac*0.8;\n  // console.log(viewportScl);\n  // should be <1 and decreasing\n  if (newPt.x < 0) return false;\n  if (newPt.x > viewportW*0.95) return false;\n  if (newPt.y < 0) return false;\n  if (newPt.y > viewportH*0.95) return false;\n}\nfunction distBtw(pt1, pt2) {\n  function sq(x) {return x*x;}\n  return Math.sqrt(sq(pt1.x-pt2.x)+sq(pt1.y-pt2.y));\n}\n/// the matrix stuff :V\nlet transfm = [1, 0, 0, \n               0, 1, 0];\nfunction translate(x, y) {\n  transfm[2] += x;\n  transfm[5] += y;\n  applyTransfm();\n}\nfunction fromCanvPos(canvX, canvY) {\n  return {x:(canvX-transfm[2])/transfm[0], y:(canvY-transfm[5])/transfm[4]};\n}\nfunction scale(scl) {\n  // matrix mult with [\n  // sclX 0\n  // 0  sclY\n  // 0  0\n  for (let i=0; i<6; i++) transfm[i]*=scl;\n  applyTransfm();\n}\nfunction applyTransfm() {\n  ctx.setTransform(transfm[0], transfm[3], transfm[1], transfm[4], transfm[2], transfm[5]);\n}\n\nfunction triangle() {\n  \n}\nfunction square() {\n\n}\nfunction circ() {\n\n}\nfunction star() {\n\n}\n\nfunction getNextType() {\n  return Math.floor(Math.random()*types.length)\n  // if ()\n}"],
  "mappings": "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",
  "names": ["dist"]
}
